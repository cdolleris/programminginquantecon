# Introduction to the Course {#sec-intro}

## Standard functions in R

R comes with a lot of standard functions. We can print stuff to the screen, invert matrices, perform OLS, generate random numbers, etc., so there is no need to reinvent the wheel every time!

These functions are also available in R packages. However, these are 'special' packages that are included by default in R and don't need to be loaded. Examples are 'stats', 'base', 'graphics',...

These functions generally have sensible names:

- `print` to print something to the screen.

- `plot` to plot figures.

- `solve` to invert a matrix.

- `lm` to perform OLS ('linear model' $\rightarrow$ 'lm')

- `sum`, `median`, `mean`,...

Obviously, there are too many to list here. R manuals are freely avaiable online <https://cran.r-project.org/>

## Small Exercise 1 {#sec-lec1-se-1 .unnumbered}

- *Open and run the* `.R` *file called* `Becoming_a_useR`*.*

::: {.callout-note collapse="true"}
## Click to view "Becoming_a_useR.R"

```{r, `code-line-numbers` = "1"}
#| eval: false
# 1. Add and remove elements from the environment
# Clear the environment: Type ctrl+L for clearing the console 
rm(list = ls()) 
Sys.setenv(lang = "en_US")
# Define an integer 
iN <- 8 

# Remove the object from the environment
rm(iN) 

# Reintroduce the integer 
iN <- 8 

# 2. There is difference between "=" and "<-" in R. Let's discuss an example
# A matrix with zero elements can be generated by a syntax: matrix(1, ncol = Nc, nrow = Nr), where Nc and Nr are some integers

mE <- matrix(0, ncol =  2)  #Saying to R the number of columns is 2
ncol                        #Comment
mR <- matrix(0, ncol <- 2)  #Saying to R the number of ?rowss is 2: 2 is assigned to ncol and it is set as nrow
ncol                        #Comment
mE # Print matrix E
mR # Print matrix R

# 3. Some error messages
# changing the value of iN
iN <- 10 
cat("... but now it is ", iN, "\n")
cat("What am I printing now? ", iN==10, "\n") # Comment
cat("Now I get an error... ", iS, "\n")       # Why?
```

:::

- *Can you understand what each line of the code does?*
- *What is the output?*
- *What are the differences in the matrices defined in line 17-19?*
  - The matrix `mE` is defined properly with 2 columns. The matrix `mR` has 2 rows.
- *Try to run lines 27-29. Can you comment the output?*
  - The error is received since the variable `iS` is not defined.
  
## Small Exercise 2 {#sec-lec1-se-2 .unnumbered}

- *Open and run the* `.R` *file called* `Exercise_error`.

::: {.callout-note collapse="true"}
## Click to view "Exercise_error.R"

```{r, `code-line-numbers` = "1"}
#| eval: false
# 0. Clear the environment:  CTRL + L to clear the Console
rm(list=ls())
Sys.setenv(lang = "en_US")
# Define vector X
vX <- c(-1,2)

# Why did the following output produce NAN output?
cat("This is square root of X: ", sqrt(vX), "\n") 
     # Why?
```

:::

- *Why do you get an error message?*
  - There is no error message. There is a warning message.
- *Which output do you get from* $\sqrt{-1}$*?*
  - Naturally, you get an error as the square root of a negative number isn't possible.
  
## External packages in R

More than 12,000 external packages are avaiable on CRAN: <https://cran.r-project.org/web/packages/>.

Knowing the name of a package, say `("rugarch")`, this can be installed in R with `install.packages("rugarch")`.

After a package has been installed, in order to load it into the R environment, we need to run: `library("rugarch")`.

## Types of variables

The function `class()` allows you to find the class of an R object. For instance:

```{r}
cfoo = "sun"
class(cfoo)
```
```{r}
bfoo = TRUE
class(bfoo)
```
```{r}
dfoo = 1.785632458
class(dfoo)
```

The "`foo`" terminology stands for a variable which is not important, i.e., a variable where intermediate results are stored. We will later see that "c", "b" , and "d" before the "foo" actually mean something!

### Vectors, Matrices, Arrays, Data frames

Data can be organized in different ways in R depending on the particular needs. If we plan to do linear algebra, we want to use:

```{r}
vY = c(1, 2, 5.48652) # vectors
mY = matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9.485), ncol = 3) # matrices
aY = array(1:27, dim = c(3, 3, 3)) # arrays
```

If we want to organize data (numeric/character or mixed), we use:

```{r}
d = data.frame(x = 1, y = 1:10, fac = LETTERS[1:10]) # data frame
```

Vectors, matrices and ararays can be: "numeric" or "character" i.e., they can contain only one of the two types of variables (we cannot have a vector with some elements "numeric" and otheres "character"). Data.frames can contain both.

### Access elements

To access elements of vectors, matrices and arrays, we use the square brackets:

```{r, `code-line-numbers` = "1"}
vY[1]
vY[1:2]
vY[c(3,1)]
mY[1, 1]
mY[1, ]
mY[1, c(1,3)]
aY[1, 1, 1]
aY[1, 1, ]
```

## How to get help

When you are in trouble the `help()` function is your friend! Whenever you want to understand the functioning of any function, say `list`, you type:

```{r}
#| eval: false
help(list)
```

This is equivalent to:

```{r}
#| eval: false
?list
```

If you don't remember the full function name, but only a part of it (or something related to it), you can use the "`??`" operator, for example:
```{r}
#| eval: false
??download
```

## Small Exercise 3 {#sec-lec1-se-3 .unnumbered}

- *Open and run the* `.R` *file called * `Get_2_know_the_helpeR.R`.

::: {.callout-note collapse="true"}
## Click to view "Get_2_know_the_helpeR.R"

```{r, `code-line-numbers` = "1"}
#| eval: false
#Clear the environment
rm(list = ls()) 
Sys.setenv(lang = "en_US")

# Define a vector A
vA <- c(1, 2, 3, 4, 5, 6) 

# Define a 2x3 matrix A
mA <- matrix(vA, nrow = 2, ncol = 3, byrow = TRUE)

# Define a 2x2 matrix B 
mB <- matrix(c(9, 8, 7, 6), ncol = 2, byrow = TRUE, nrow = 2) 

# Print matrix B
mB

# Find out what the function crossprod (from the "base" package) does via the help() function
mC <- crossprod(mA,mB) 
mC

# The below matrix will give you an error. Try to reproduce the matrix mC via linear algebra based on what you learned from the help function!
mD <- mA %*% mB 
# Hint: Try ??transpose and look for Matrix Transpose.
mD <- t(mA) %*% mB 
mD # Print matrix D

# Use one of the below to test if mC and mD are equal
all.equal(mC,mD) # Check if all mC and mD are equal, returns "TRUE" if this is mC = mD.
vCheck <- c(mC) == c(mD) # Form a vector of booleans, look up ?'=='
all(vCheck) # Check if all mC and mD are equal, returns "TRUE" if mC = mD.
```

:::

- *Run the code line by line. Do you understand it?*
- *Try to look up some of the functions with the* `help`*-function*.
- *Discover how to transpose* `mA` *to obtain* `mD`*?*
```{r}
#| eval: false
md <- t(mA) %*% mB
```
- *Evaluate whether your* `mD` *is equal to* `mC`.
```{r}
#| eval: false
all.equal(mC,mD) # Check if all mC and mD are equal, returns "TRUE" if this is mC = mD.
vCheck <- c(mC) == c(mD) # Form a vector of booleans, look up ?'=='
all(vCheck) # Check if all mC and mD are equal, returns "TRUE" if mC = mD.
```

## Small Exercise 4 {#sec-lec1-se-4 .unnumbered}

- *Try to install the package "Rfast". (Hint: Go back a couple of slides to find the relevant function).*

```{r}
#| eval: false
install.packages("Rfast")
```

- *Load the package and try the following code:*
```{r message=FALSE, warning=FALSE, results='hide'}
library("Rfast") # Loads the package
mA <- matrix(1:100,10,10)
rowVars(mA)
```

- *There are only a finite amount of names to call functions (especially if it has to make sense).*
*What happens if you have two packages that have a similar name? E.g.,* `rowVars` *from* `Rfast` *and* `matrixStats`*?*

Either use:

```{r}
#| eval: false
detach("package:Rfast", unload=TRUE)
```

Or by the use of namespaces, i.e., `Rfast::rowVars(mA)` to run the function from the package we want. (This syntax also carries over to other programming languagues, e.g., directly to C++)

## Additional code in R

::: {.callout-note collapse="true"}
## Click to view "Week1_lecture1.R"

```{r, `code-line-numbers` = "1"}
#| eval: false
# 0. Clear the environment:  CTRL + L to clear the Console
rm(list=ls())
Sys.setenv(lang = "en_US")

# 1. How to install packages: "rugarch" a package for Univariate GARCH Models
install.packages("rugarch")
library(rugarch)

# 2. How to use help to learn more about this package
# 2.1. General info about the entire package
help("rugarch")
# or 
?rugarch

# 2.2. Info on a specific command from the package
topic <- "VaRplot"
pkg_ref <- "rugarch"
help((topic),(pkg_ref))
#or
help("VaRplot")
#or type if you are not sure about the name
??VaRp

# 3. Types of variables: Character,Logical,Numeric
cfoo = "sun"
class(cfoo)

bfoo = TRUE
class(bfoo)

dfoo = 1.785632458
class(dfoo)

# 4. Vectors and matrices
# 4.1. Define a vector
vX <- c(1,2,3) 
#or alternatively
vX <- c(1:3)
#Another alternative for a step size Step=1
Step<-1
vX <-seq(1, 3, by=Step) 
#Take a look at the seq() function
?seq

# Length of the vector
n<-length(vX)
# Generate a diagonal matrix with elements of vX on the main diagonal
dX<- diag(vX)
# Return a vector consisting of the diagonal elements of dX
print(diag(dX))
# For a scalar K create an identity matrix
K<-5
I<-diag(K)
print(I)

# 4.2. Different ways of specifying matrices
# 3x3 Matrices: elements are allocated by row
mX <- matrix(vX, ncol = 3, nrow = 3, byrow = TRUE)
print(mX)
mX <- matrix(vX, ncol = 3, nrow = 3, byrow = 1) 
print(mX)

# 3x3 Matrices: elements are allocated  by column
mX <- matrix(vX, ncol = 3, nrow = 3, byrow = FALSE)
print(mX)
mX <- matrix(vX, ncol = 3, nrow = 3, byrow = 0) 
print(mX)

# Number of elements in a matrix
nm<-length(mX)

# Dimensions of a matrix
nm<-dim(mX)


# Accessing Elements
dC <- mX[2, 3] # 2nd row, 3rd column
vC <- mX[, 3] # all rows, 3rd column
dD <- mX[, 3][1] # 1st row, 3rd column
vD <- mX[2, ] # 2nd row, all columns


# Accessing Elements of a vector
vX[1]
vX[2]
vX[n]

# A matrix where each element is h
h<-1
mh<-matrix(h, ncol = 3, nrow = 4)

# 4.3. Matrix manipulations
# 4.3.1. Add, Subtract...
mA <- matrix(c(1, 2, -4, 7, 2, 3), nrow = 2)
print(mA)
mB <- matrix(c(3, 8, 2, 9, 1, 4), nrow = 2)
print(mB)

# Add and subtract
print(mA + mB)
print(mA - mB)

# 4.3.2. Multiplication, Matrix transpose
# Element by element multiplication
print(mA*mB)

# Matrix multiplication: this Will report an error because... 
print(mA%*%mB)

#Let's introduce matrix transpose 
print(t(mB))
print(mA%*%t(mB))

# Or
print(t(mA)%*%(mB))

#Similarly A'*B can be calculated as
crossprod(mA,mB)

# Let's multiply the matrix A with a vector vX
print(mA%*%vX)

# 4.3.3. Matrix inversion
# Define an invertible matrix
mC <- matrix(c(1, 0.5, 0.9, 0.5, 1, 0.4, 0.9, 0.4, 1), ncol = 3, nrow = 3, byrow = TRUE)
# Inverse of a matrix
invC <- solve(mC)
# One can verify this invC%*%C must be an identity matrix
print(invC%*%mC)


# 5. Array
# 3 matrices each 3x3
aY = array(1:27, dim = c(3, 3, 3))
print(aY)
# First matrix in the array 
aY[,,1]
# Second matrix in the array 
aY[,,2]
# (1,2) element of the Second matrix in the array 
aY[1,2,2]
# (1,2) element of the each matrix in the array 
aY[1,2,]

#6. Data frames
d <- data.frame(x = 1, y = 1:10, l = LETTERS[1:10]) 
#Visualize the data
print(d )
#extract the first series
d$y
#extract the second series
d$x
#extract the third series
d$l

```

:::
